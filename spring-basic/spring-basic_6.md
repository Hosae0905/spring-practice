## 컴포넌트 스캔

### 컴포넌트 스캔과 의존관계 자동 주입
- 빈을 일일이 등록하기 귀찮고 누락이 발생하는 문제가 발생한다.
- 스프링 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- 의존관계도 자동으로 주입하는 @Autowired 기능도 제공한다.
- 컴포넌트 스캔을 사용하면 @Component가 붙은 것들을 빈으로 등록해준다.
- 보통 실무에서는 컴포넌트 스캔 대상을 제외시키진 않는다.
- 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
- 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다. (getBean()으로 조회하는 것과 동일하다고 이해하면 된다.)
- 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
- 생성자에 파라미터가 많아도 다 찾아서 자동으로 주입한다.

### 탐색 위치와 기본 스캔 대상
- 모든 자바 클래스들을 다 스캔하려면 너무 오래 걸린다. 그래서 꼭 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다.
- 따로 지정하지 않으면 @ComponentScan이 붙은 클래스가 있는 패캐지부터 하위 패키지까지 스캔을 한다.
- 스프링 부트를 사용하면 컴포넌트 스캔을 따로 설정하는 일이 별로 없음
- 컴포넌트 스캔 기본 대상(소스 코드에 @Component가 붙어 있다.)
  - @Component
  - @Controller
  - @Service
  - @Repository
  - @Configuration
- 애노테이션에는 상속관계가 없다. 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능이 아니고 스프링에서 지원하는 기능이다.
- 위의 애노테이션을 붙이면 스프링은 부가 기능을 수행한다.

### 필터
- includeFilters: 컴포넌트 스캔 대상을 추가로 지정
- excludeFilters: 컴포넌트 스캔에서 제외할 대상을 지정
- includeFilters를 사용할 일은 거의 없다. excludeFilters는 간혹 사용할 때가 있지만 많지 않다.
- 최대한 스프링 부트에서 제공하는 기본 값에 최대한 맞춰서 사용하는 것이 좋다.

### 중복 등록과 충돌
- 컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까?
- 자동 빈 등록 vs 자동 빈 등록
  - 이름이 같은 빈을 자동으로 등록하게 되면 스프링에서 오류(ConflictingBeanDefinitionException)를 발생시킨다.
- 수동 빈 등록 vs 자동 빈 등록
  - 이러한 경우 수동 빈 등록이 우선권을 가진다.
  - 수동 빈이 자동 빈을 오버라이딩한다.
- 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류를 발생시키며 꺼진다.
- 명확하지 않으면 즉, 애매하면 하지 말자
- 
