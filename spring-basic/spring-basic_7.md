## 의존관계 자동 주입

### 다양한 의존관계 주입 방법
- 의존관계 주입 방법 4가지
  1. 생성자 주입
  2. 수정자 주입(setter 주입)
  3. 필드 주입
  4. 일반 메서드 주입
- 생성자 주입
  - 생성자를 통해서 의존 관계를 주입 받는 방법
  - 특징
    - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
    - 불변, 필수 의존관계에 사용한다.
    - 외부에서 수정이 가능해져 버리면 오류가 발생할 수 있다. 따라서 필드를 private으로 제한하고 생성자를 통해서만 주입할 수 있게 하는 것이 좋다.
    - 생성자가 1개만 있으면 @Autowired를 생략할 수 있다.
    - 빈을 등록하면서 의존 관계 주입을 동시에 할 수 있다.
- 수정자 주입(setter 주입)
  - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법이다.
  - 특징
    - 선택, 변경 가능성이 있는 의존관계에 사용한다.
    - 자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
    - 파라미터로 들어오는 객체가 빈으로 등록되지 않았을 때도 사용할 수 있다.
    - @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 따라서 설정 값으로 required = false로 지정해줘야 오류없이 동작한다.
- 필드 주입
  - 의존 관계를 필드에 바로 주입하는 방법이다.
  - 특징
    - 코드가 간결해진다.
    - 하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
    - DI 프레임워크가 없으면 아무것도 할 수 없다. --> 순수 자바 코드로 테스트가 불가함
    - 애플리케이션의 실제 코드와 관계 없는 테스트 코드에 사용할 수 있다.
    - 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용한다.
    - 이것 외에는 사용하지 않는 것이 좋다.
- 일반 메서드 주입
  - 일반 메서드를 통해서 주입 받을 수 있다.
  - 특징
    - 한 번에 여러 필드를 주입 받을 수 있다.
    - 일반적으로 잘 사용하지 않는다.

### 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
- 따라서 자동 주입 대상을 옵션으로 처리하는 방법이 있다.
  - @Autowired(required = false): 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안 된다.
  - org.springframework.lang.@Nullable: 자동 주입할 대상이 없으면 null이 입력된다.
  - Optional<>: 자동 주입할 대상이 없으면 Optional.empty가 된다. 

### 생성자 주입을 선택하는 이유
- 최근에는 스프링을 포함한 다른 DI 프레임워크 대부분이 생성자 주입을 권장한다. 왜 그럴까?
- 불변
  - 대부분의 의존관계 주입은 한 번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
  - 오히려 대부분의 의존관계는 종료 전까지 변하면 안 된다.
  - 수정자 주입을 사용하면 public으로 수정자를 열어둬야 하기 때문에 실수로 변경할 수 있다.
  - 생성자 주입을 사용하면 딱 1번만 호출되므로 불변하게 설계할 수 있다.
- 누락
  - 프레임워크 없이 순수한 자바 코드로 단위 테스트를 하는 경우 유용하다. 
  - final 키워드를 통해 개발자가 실수로 의존관계 주입을 누락하는 것을 막을 수 있다.
  - 생성자 주입을 통해 final 키워드를 넣을 수 있다는 것이 좋다.
  - 생성자 주입 방식 외에 다른 주입 방식은 final 키워드를 사용할 수 없다.
- 항상 생성자 주입 방식을 선택하고 필요에 따라서 수정자 주입 방식을 적용하자.
- 필드 주입을 사용하지 말자.

### 롬복과 최신 트렌드


### 조회 빈이 2개 이상일 때 문제
- @Autowired 애노테이션은 타입으로 조회한다. (마치 ac.getBean(DiscountPolicy.class)와 유사하게 동작하게 된다. --> 실제로는 더 많은 기능을 제공함)
- 스프링 빈 조회해서 봤듯이 타입으로 조회하면 선택된 빈이 2개 이상일 때 문제가 생긴다.
- (오류 발생) No qualifying bean of type 'project.springbasic.discount.DiscountPolicy' 
  available: expected single matching bean but found 2: fixDiscountPolicy,rateDiscountPolicy
- 하위 타입으로 지정할 수 있지만 DIP를 위배하고 유연성이 떨어진다.
- 그리고 이름만 다르고 완전히 똑같은 타입의 스프링 빈이 2개 있을때 해결이 안 된다.
- 빈을 수동으로 등록해서 문제를 해결할 수도 있지만 자동 주입으로도 해결할 수 있다.

### @Autowired 필드 명, @Qualifier, @Primary
- 앞서 살펴본 빈이 2개 이상일 때 문제를 해결하는 방법으로는 3가지가 있다.
  1. @Autowired 필드 명
     - @Autowired는 처음에 타입 매칭을 시도하는데 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
     - 필드 명 매칭은 먼저 타입 매칭을 시도 하고 그 결과에 여러 빈이 있을때 추가로 동작하는 기능이다.
  2. @Qualifier
     - 추가 구분자를 붙여주는 방법이다.
     - 주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.
     - 만약에 @Qualifier로 주입한 구분자로 찾지 못하면 해당 구분자를 이름으로 하는 스프링 빈을 추가로 찾는다.
     - @Qualifier는 @Qualifier를 찾는 용도로만 사용하는게 명확하고 좋다.
  3. @Primary
     - 우선순위를 정하는 방법이다.
     - @Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 가진다.
     - @Qualifier는 주입을 받을 때 모든 코드에 @Qualifier를 붙여줘야 하지만 @Primary는 우선권을 부여할 클래스에만 붙여주면 되서 편리하게 사용할 수 있다.
     - @Primary는 기본값처럼 동작하고 @Qualifier는 매우 상세하게 동작한다. 만약 두개를 동시에 사용한다면 어떤 것이 우선권을 가지게 될까
     - 스프링은 자동보다 수동이, 넓은 범위의 선택보다 좁은 범위의 선택권이 우선 순위가 높다. 따라서 @Qualifier가 우선권이 높다.

### 애노테이션 직접 만들기
- @Qualifier를 사용할때 문자를 적으면 컴파일시 타입 체크가 안된다. 따라서 애노테이션을 만들어서 깔끔하게 운영할 수 있다.
- 문자는 컴파일시 타입 체크가 안되서 오타가 나도 그냥 실행된다.
- 애노테이션은 상속이라는 개념이 없다. 따라서 여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 기능이다.
- 스프링이 제공하는 기능을 뚜렷한 목적 없이 무분별하게 재정의 하는 것은 유지보수에 혼란을 가중할 수 있기 때문에 재정의 하는 것은 피하자.

### 조회한 빈이 모두 필요할 때 List, Map
- 의도적으로 해당 타입의 스프링 빈이 다 필요한 경우도 있다.
- 예를 들어서 할인 서비스를 제공하는데 클라이언트가 할인의 종류를 선택할 수 있다고 가정해보자. 스프링을 사용하면 소위 말하는 전략 패턴을 매우 간단하게 구현할 수 있다.
- Map이나 List로 특정 타입의 스프링 빈을 다 저장한다.
- 그 후 원하는 특정 타입을 문자열로 넣어서 빈을 찾아 비즈니스 로직을 작성할 수 있다.

### 자동, 수동의 올바른 실무 운영 기준
- 편리한 자동 기능을 기본으로 사용하자.
- 애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.
  - 업무 로직 빈: 웹을 지원하는 컨트롤러, 비즈니스 로직이 있는 서비스, 데이터 계층 로직을 처리하는 리포지토리등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
  - 기술 지원 빈: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나 공통 로그 처리와 같이 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.
- 업무 로직은 숫자도 매우 많고 유사한 패턴이 있다. 따라서 자동 기능을 적극적으로 사용하는 것이 좋다.
- 기술 지원 빈은 수가 매우 적고 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 또한 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다.
  따라서 이러한 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.
- 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수하기 좋다.
- 비즈니스 로직 중에서 다형성을 적극 활용할 때 수동 빈 등록이 더 유리한 경우도 있다.
- 자동 빈 등록을 사용하면 다른 개발자가 봤을때 코드를 한 눈에 파악하기 힘들기 때문에 수동 빈으로 등록하거나 자동으로 하려면 특정 패키지에 같이 묶어 두는 것이 좋다.
- 핵심은 한 눈에 보고 이해가 되어야 한다는 것
- 참고로 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외다.
- 스프링 부트가 아니라 내가 직접 기술 지원 객체를 스프링 빈으로 등록한다면 수동으로 등록해서 명확하게 들어내는 것이 좋다.
