## 검증1 - Validation

### 검증 요구사항
- 컨트롤러의 중요한 역할 중 하나는 HTTP 요청이 정상인지 검증하는 것이다.
- 정상 로직보다 검증 로직을 잘 개발하는 것이 어쩌면 더 어려울 수 있다.
- 클라이언트와 서버 검증
  - 클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
  - 서버만으로 검증하면 즉각적인 고객 사용성이 부족해진다.
  - 둘을 적절히 섞어서 사용하되 최종적으로 서버 검증은 필수
  - API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 넘겨줘야 함

### BindingResult1
- BindingResult의 파리미터 위치는 @ModelAttribute 다음에 와야 한다. 그래야지 어떤 객체에 대한 결과를 담을지 알 수 있기 때문이다.

### BindingResult2
- BindingResult는 스프링이 제공하는 검증 오류를 보관하는 객체이다. 검증 오류가 발생하면 여기에 보관하면 된다.
- 입력 값의 타입이 잘못되면 BindingResult가 있을 경우 오류 정보를 담아서 컨트롤러를 정상 호출한다.
- 하지만 BindingResult가 없다면 컨트롤러를 호출하지 못하고 바로 에러 페이지로 이동한다.
- BindingResult에 검증 오류를 적용하는 3가지 방법
  - 스프링이 FieldError 생성해서 BindingResult에 넣어준다.
  - 개발자가 직접 넣어준다.
  - Validator를 사용한다.
- 파라미터 순서가 중요하다.
- 오류가 발생했을때 입력 값이 유지가 되지 않는 문제가 생길 수 있다.

### FieldError, ObjectError
- FieldError 생성자에 여러 정보를 담아서 오류가 발생해도 입력 값이 유지가 되도록 만들 수 있다.
- 사용자의 입력 데이터가 컨트롤러의 @ModelAttribute에 바인딩되는 시점에 오류가 발생하면 모델 객체에 사용자 입력 값을 유지하기 어렵다.
- 예를 들어 가격에 숫자가 아닌 문자가 입력된다면 가격은 Integer 타입이므로 문자를 보관할 수 있는 방법이 없다.
- 그래서 오류가 발생한 경우 사용자 입력 값을 보관하는 별도의 방법이 필요하다. 그리고 이렇게 보관한 사용자 입력 값을 검증 오류 발생 시 화면에 다시 출력하면 된다.
- FieldError가 값을 가지고 있는 역할을 하게 된다.

### 오류 코드와 메시지 처리1
- 에러 메시지는 일관성 있게 관리해야 한다.

### 오류 코드와 메시지 처리2
- 컨트롤러에서 BindingResult는 검증해야 할 객체인 target 바로 다음에 온다. 따라서 BindingResult는 이미 본인이 검증해야 할 객체인 target을 알고 있다.
- reject(), rejectValue()로 더 간단하게 코드를 작성할 수 있다.
- 따로 메시지 소스와 매칭하지 않아도 오류 메시지를 잘 찾아서 출력해준다. 뭔가 규칙이 있는 것처럼
- MessageCodesResolver를 이해해야 알 수 있다.

### 오류 코드와 메시지 처리3
- 어떤 식으로 오류 코드를 설계할 것인가?
- 단순하게 만들면 범용성이 좋지만 메시지를 세밀하게 작성하기 어렵다.
- 반대로 너무 자세하게 만들면 범용성이 떨어진다.
- 범용성있게 사용하다가 세밀하게 작성할 필요가 있을때 세밀한 내용이 적용되도록 메시지에 단계를 두는 방법이 있다.
- 우선순위를 부여해서 사용할 수 있다.
- 우선순위를 사용하면 추가 개발 없이 메시지의 추가 만으로 매우 편리하게 오류 메시지를 관리할 수 있다.
- 스프링 MessageCodesResolver라는 것으로 이러한 기능을 지원한다.

### 오류 코드와 메시지 처리4
- MessageCodesResolver는 검증 오류 코드로 메시지 코드들을 생성한다.
- DefaultMessageCodesResolver가 구현체이다.
- DefaultMessageCodesResolver의 기본 메시지 생성 규칙
  - 객체 오류의 경우 다음 순서로 2가지 생성
    - code + "." + object name
    - code
  - 필드 오류의 경우 다음 순서로 4가지 메시지 코드 생성
    - code + "." + object name + "." + field
    - code + "." + field
    - code + "." + field type
    - code
- rejectValue(), reject()는 내부에서 MessageCodesResolver를 사용한다. 여기에서 메시지 코드들을 생성한다.

### 오류 코드와 메시지 처리5
- 오류 코드 관리 전략의 핵심은 구체적인 것에서 덜 구체적인 것으로
- 구처젝인 것을 먼저 만들어주고 덜 구체적인 것을 가장 나중에 만든다.
- 이렇게 하면 앞서 말한 것 처럼 메시지와 관련된 공통 전략을 편리하게 도입할 수 있다.
- 모든 오류 코드에 대해서 메시지를 각각 다 정의하면 개발자 입장에서 관리하기 너무 힘들다.
- 크게 중요하지 않은 메시지는 범용성 있는 메시지로 끝내고 정말 중요한 메시지는 꼭 필요할때 구체적으로 적어서 사용하는 방식이 더 효과적이다.

### 오류 코드와 메시지 처리6
- 검증 오류 코드는 2가지로 나눌 수 있다.
  - 개발자가 직접 설정한 오류 코드 --> rejectValue()를 직접 호출한 경우
  - 스프링이 직접 검증 오류를 추가한 경우(주로 타입 정보가 맞지 않음)
- typeMismatch.item.price 이런 식으로 스프링에서 직접 넣어준다.

### Validator 분리
- 복잡한 검증 로직은 별도로 분리하자.
- 검증 로직이 차지하는 부분이 매우 크면 별도의 클래스로 역할을 분리하는 것이 좋다.
- 분리하면 재사용도 가능해진다.

### Validator 분리 2
- 스프링이 Validator 인터페이스를 별도로 제공하는 이유는 체계적으로 검증 기능을 도입하기 위해서다.
- Validator 인터페이스를 사용해서 검증기를 만들면 스프링의 추가적인 도움을 받을 수 있다.
- WebDataBinder
  - 컨트롤러 호출할 때마다 항상 init 메서드가 먼저 호출되면서 검증기를 자동으로 넣어준다.
  - @InitBinder는 해당 컨트롤러에만 영향을 준다. 글로벌 설정은 따로 해줘야 한다.
  - 검증이 필요한 대상 앞에 @Validated를 붙이면 사용할 수 있다.
- @Validated는 검증기를 실행하라는 애노테이션이다.
- 해당 애노테이션이 붙으면 앞서 WebDataBinder에 등록한 검증기를 찾아서 실행한다.
- 그런데 여러 검증기를 등록한다면 그 중에 어떤 검증기가 실행되어야 할지 구분이 필요하다.
- 이때 supports() 메서드가 사용되면서 타입을 확인하고 true면 validate()가 호출된다.
